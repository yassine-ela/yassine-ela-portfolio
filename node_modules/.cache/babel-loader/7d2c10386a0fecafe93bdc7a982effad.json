{"ast":null,"code":"import SequentialIDGenerator from \"../sequential-id-generator\";\nimport { Cache, MultiCache } from \"../cache\";\nimport injectStylePrefixed from \"../inject-style-prefixed\";\nimport { styleBlockToRule, atomicSelector, keyframesBlockToRule, declarationsToBlock, keyframesToBlock, fontFaceBlockToRule } from \"../css\";\nclass StyletronServer {\n  constructor(opts = {}) {\n    this.styleRules = {\n      \"\": \"\"\n    };\n    this.styleCache = new MultiCache(new SequentialIDGenerator(opts.prefix), media => {\n      this.styleRules[media] = \"\";\n    }, (cache, id, value) => {\n      const {\n        pseudo,\n        block\n      } = value;\n      this.styleRules[cache.key] += styleBlockToRule(atomicSelector(id, pseudo), block);\n    });\n    this.fontFaceRules = \"\";\n    this.fontFaceCache = new Cache(new SequentialIDGenerator(opts.prefix), (cache, id, value) => {\n      this.fontFaceRules += fontFaceBlockToRule(id, declarationsToBlock(value));\n    });\n    this.keyframesRules = \"\";\n    this.keyframesCache = new Cache(new SequentialIDGenerator(opts.prefix), (cache, id, value) => {\n      this.keyframesRules += keyframesBlockToRule(id, keyframesToBlock(value));\n    });\n  }\n  renderStyle(style) {\n    return injectStylePrefixed(this.styleCache, style, \"\", \"\");\n  }\n  renderFontFace(fontFace) {\n    const key = JSON.stringify(fontFace);\n    return this.fontFaceCache.addValue(key, fontFace);\n  }\n  renderKeyframes(keyframes) {\n    const key = JSON.stringify(keyframes);\n    return this.keyframesCache.addValue(key, keyframes);\n  }\n  getStylesheets() {\n    return [...(this.keyframesRules.length ? [{\n      css: this.keyframesRules,\n      attrs: {\n        \"data-hydrate\": \"keyframes\"\n      }\n    }] : []), ...(this.fontFaceRules.length ? [{\n      css: this.fontFaceRules,\n      attrs: {\n        \"data-hydrate\": \"font-face\"\n      }\n    }] : []), ...sheetify(this.styleRules, this.styleCache.getSortedCacheKeys())];\n  }\n  getStylesheetsHtml(className = \"_styletron_hydrate_\") {\n    return generateHtmlString(this.getStylesheets(), className);\n  }\n  getCss() {\n    return this.keyframesRules + this.fontFaceRules + stringify(this.styleRules, this.styleCache.getSortedCacheKeys());\n  }\n}\nexport function generateHtmlString(sheets, className) {\n  let html = \"\";\n  for (let i = 0; i < sheets.length; i++) {\n    const sheet = sheets[i];\n    const {\n      class: originalClassName,\n      ...rest\n    } = sheet.attrs;\n    const attrs = {\n      class: originalClassName ? `${className} ${originalClassName}` : className,\n      ...rest\n    };\n    html += `<style${attrsToString(attrs)}>${sheet.css}</style>`;\n  }\n  return html;\n}\nfunction attrsToString(attrs) {\n  let result = \"\";\n  for (const attr in attrs) {\n    const value = attrs[attr];\n    if (value === true) {\n      result += \" \" + attr;\n    } else if (value !== false) {\n      result += ` ${attr}=\"${value}\"`;\n    }\n  }\n  return result;\n}\nfunction stringify(styleRules, sortedCacheKeys) {\n  let result = \"\";\n  sortedCacheKeys.forEach(cacheKey => {\n    const rules = styleRules[cacheKey];\n    if (cacheKey !== \"\") {\n      result += `@media ${cacheKey}{${rules}}`;\n    } else {\n      result += rules;\n    }\n  });\n  return result;\n}\nfunction sheetify(styleRules, sortedCacheKeys) {\n  if (sortedCacheKeys.length === 0) {\n    return [{\n      css: \"\",\n      attrs: {}\n    }];\n  }\n  const sheets = [];\n  sortedCacheKeys.forEach(cacheKey => {\n    // omit media (cacheKey) attribute if empty\n    const attrs = cacheKey === \"\" ? {} : {\n      media: cacheKey\n    };\n    sheets.push({\n      css: styleRules[cacheKey],\n      attrs\n    });\n  });\n  return sheets;\n}\nexport default StyletronServer;","map":null,"metadata":{},"sourceType":"module"}